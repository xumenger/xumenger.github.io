---
layout: post
title: Unity 随笔
categories: 游戏开发之unity 好好玩游戏 
tags: 游戏 Unity 3D 物理系统 图形 C# 音频 动画 UI 导航 
---

>Unity 官方文档：[https://docs.unity.cn/cn/2021.3/Manual/UnityManual.html](https://docs.unity.cn/cn/2021.3/Manual/UnityManual.html)

游戏对象是 Unity 中的基础对象，表示角色、道具和景物。它们本身并没有取得多大作为，但它们充当组件的容器，而组件可实现功能

为了给游戏对象添加3D 模型，需要添加一个Mesh Filter 组件；Mesh Render 组件用于在场景中渲染网格

如果游戏对象在运行时未移动，则被称为静态游戏对象。如果游戏对象在运行时移动，则被称为动态游戏对象

Unity 的[预制件系统](https://docs.unity.cn/cn/2021.3/Manual/Prefabs.html)允许创建、配置和存储游戏对象及其所有组件、属性值和子游戏对象作为可重用资源。预制件资源充当模板，在此模板的基础之上可以在场景中创建新的预制件实例

约束组件将游戏对象的位置、旋转或缩放与另一个游戏对象关联。受约束的游戏对象像关联到的游戏对象一样移动、旋转或缩放。Unity 支持以下约束组件：Aim、Look At、Parent、Position、Rotation、Scale

光源是每个场景必不可少的部分。虽然网格和纹理定义了场景的形状和外观，但光源定义了3D 环境的颜色和氛围。在每个场景中可能会使用多个光源。让这些光源协同工作需要一些精力，但可能会带来非常令人惊叹的结果

在Unity 图像的导入设置中，可选择将其导入为纹理、2D 精灵还是法线贴图。在FBX 文件的导入设置中，可调整比例、生成法线或光照贴图坐标以及拆分和修剪文件中定义的动画剪辑

AssetBundle 是一个存档文件，包含可在运行时由Unity 加载的特定于平台的非代码资源（比如模型、纹理、预制件、音频剪辑甚至整个场景）。AssetBundle 可以表示彼此之间的依赖关系；例如，一个AssetBundle 中的材质可以引用另一个AssetBundle 中的纹理。为了提高通过网络传输的效率，可以根据用例要求（LZMA 和 LZ4）选用内置算法选择来压缩AssetBundle。AssetBundle 可用于可下载内容（DLC），减小初始安装大小，加载针对最终用户平台优化的资源，以及减轻运行时内存压力

渲染管线执行一系列操作来获取场景的内容，并将这些内容显示在屏幕上。概括来说，包括：提出、渲染、后期处理

在Graphics Settings 和Quality Settings 都可以设置渲染管线，在Graphics Settings 配置的是默认使用的渲染管线（GraphicsSettings.defaultRenderPipeline），在Quality Settings 可以针对指定的质量等级override 默认的渲染管线（QualitySettings.renderPipeline）

在[前向渲染](https://docs.unity.cn/cn/2021.3/Manual/RenderTech-ForwardRendering.html)中，影响每个对象的一些最亮的光源以完全逐像素光照模式渲染。然后，最多4 个点光源采用每个顶点计算方式。其他光源以球谐函数（SH）计算，这种计算方式会快很多，但仅得到近似值

在前向渲染过程中，Unity 会查找网格周围的所有光源，并计算出哪些光源对网格的影响最大。使用Quality 窗口上的设置可修改多少个光源用于像素光照以及多少个用于顶点光照。每个光源根据它与网格的距离以及它的光照强度来计算其重要性；纯粹从游戏背景而言，有些光源比另一些光源更重要。鉴于此原因，每个光源都有Render Mode 设置，可设置为Important 或Not Important；标记为Not Important 的光源具有较低的渲染开销

[CommandBuffer](https://docs.unity.cn/cn/2021.3/Manual/GraphicsCommandBuffers.html) 保存渲染命令列表（例如设置渲染目标或绘制给定网格）。您可以指示Unity 在内置渲染管线中的各个点安排和执行这些命令，因此，您可以自定义和扩展Unity 的渲染功能

一旦我们开始使用法线贴图，表面法线本身需要按每个像素计算，这意味着我们还必须按每个像素计算环境的反射方式

Unity 的[可编程渲染管线 (Scriptable Render Pipeline, SRP)](https://docs.unity.cn/cn/2021.3/Manual/scriptable-render-pipeline-introduction.html) 是一项可以通过C# 脚本来控制渲染的功能。SRP 技术可以强化通用渲染管线 (URP) 和高清渲染管线 (HDRP)。可编程渲染管线是一个瘦API 层，允许使用C# 脚本来调度和配置渲染命令。Unity 将这些命令传递给它的低级图形架构，后者随后将指令发送给图形API

Camera可生成深度、深度+法线或运动矢量纹理。这是一种极简化的G 缓冲纹理，可用于后期处理效果或实现自定义光照模型（例如光照预通道）

来自摄像机的射线最常见的用途是将射线投射 (raycast) 到场景中。射线投射从原点沿着射线方向发送假想的“激光束”，直至命中场景中的碰撞体。随后会返回有关该对象和RaycastHit 对象内的投射命中点的信息。这是一种基于对象在屏幕上的图像来定位对象的非常有用的方法

可创建多个摄像机，并将每个摄像机分配给不同的深度 (Depth)。按照从低深度到高深度的顺序绘制摄像机。换言之，深度为2 的摄像机将绘制在深度为1 的摄像机之上。您可以调整Normalized View Port Rectangle 属性的值，从而调整屏幕上摄像机视图的大小和位置。这样就能创建多种迷你视图，如导弹摄像机、地图视图、后视镜等

阴影为场景添加了一定程度的深度和真实感，因为它们可以显示对象的比例和位置，否则对象看起来显得扁平。在Unity 中，光源可将游戏对象的阴影投射到其自身的其他部分或附近的游戏对象上

方向光通常模拟太阳光，单个方向光即可照亮整个场景。这意味着方向光的阴影贴图会覆盖场景的大部分，因此可能会引起称为“透视锯齿”的问题。透视锯齿是指靠近摄像机的阴影贴图像素看起来比那些更远的像素更大块

通过光照探针可以捕获并使用穿过场景空白空间的光线的相关信息。与光照贴图类似，光照探针存储了有关场景中的光照的“烘焙”信息。不同之处在于，光照贴图存储的是有关光线照射到场景中的表面的光照信息，而光照探针存储的是有关光线穿过场景中的空白空间的信息。光照探针是在烘焙期间测量（探测）光照的场景位置。在运行时，系统将使用距离动态游戏对象最近的探针的值来估算照射到这些对象的间接光。

光照探针有两个主要用途：光照探针的主要用途是为场景中的移动对象提供高质量的光照（包括间接反射光）；光照探针的次要用途是在静态景物使用Unity 的LOD（细节级别）系统时提供该景物的光照信息

可将Light Probe Group 组件添加到场景中的任何游戏对象。但是，最好创建一个新的空游戏对象（菜单：GameObject > Create Empty），然后将该组件添加到这个游戏对象，从而降低意外将该组件从项目中移除的可能性

Unity 内部使用.fbx 文件格式作为其导入链。最佳做法尽可能使用.fbx 文件格式，并且不应在生产中使用专有文件格式

如果使用两个带蒙皮的网格代替单个网格，模型的渲染时间大概会是单个网格的两倍，并且这样做很少能带来实际的意义

一般来说，骨骼的数量越少，性能就越好。但有些时候，您需要创建具有大量骨骼的角色模型：例如，在需要大量可自定义的附件时。这些额外骨骼会增加构建大小，并且每个额外的骨骼都可能带来相对处理成本。例如，在通用模式下，已拥有30 个骨骼的绑定上增加15 个骨骼会让Unity 再花费50% 的时间来解析，这可能会影响解析所花费的时间

在导入动画时，Unity 会将模型的反向动力学 (IK) 节点将烘焙为正向动力学 (FK)，因此Unity 根本不需要IK 节点。但是，如果这些节点留在了模型中，那么即使不影响动画，Unity 也会计算它们。可以在Unity 或3D 建模应用程序中删除冗余的IK 节点。为了方便删除IK 节点，应在建模时保留单独的IK 和FK 层级视图

通过[Avatar 遮罩功能](https://docs.unity.cn/cn/2021.3/Manual/ConfiguringtheAvatar.html)可以丢弃剪辑中的一些动画数据，从而让剪辑仅动画化对象或角色的某些部分而不是整体。例如，可能有一个标准的行走动画，其中包括手臂和腿部运动，但如果一个角色用双手抱着大型物体，那么不会希望其手臂在行走时向侧面摆动。但是，仍然可以在角色抱着物体时使用标准行走动画，但需要使用遮罩在行走动画的上层仅播放抱着物体动画的上半身部分

Unity 会处理并显示由三角形组成的几何体，而不是由四边形组成的几何体。这意味着一个四边形图元包含两个三角形

LOD 技术允许Unity 根据与摄像机的距离来相应减少为游戏对象渲染的三角形数量。要使用此技术，游戏对象必须具有大量网格，这些网格的几何体的细节级别逐渐降低。这些网格称为LOD 级别。游戏对象离摄像机越远，Unity 渲染的LOD 细节级别越低。此技术减轻了这些远处游戏对象给硬件带来的负担，因此可以提高渲染性能

必须使用材质将纹理应用于对象。材质使用称为着色器的专用图形程序在网格表面上渲染纹理。着色器可实现光照和着色效果，从而模拟许多其他事物的闪亮或凹凸表面。此外，它们还可一次使用两个或更多纹理，将这些纹理组合起来以获得更大的灵活性

网格非常适合表示固体对象，但不太适合表现魔法留下的火焰、烟雾和火花等对象。粒子系统可以更好地处理这种类型的效果。粒子是一个小型2D 图形，用于表示一小部分基本为流体或气体的东西，例如烟幕云团。当许多这样的粒子一次性创建完成并开始运动（还可能有随机变化）时，它们可产生非常令人信服的效果。例如，可通过从中心点以极快的速度发出带有火焰纹理的粒子来表现爆炸。此外，可通过从场景中的高处加速落下水粒子来模拟瀑布

当需要显示着色器变体时，它会检查Library/ShaderCache 文件夹。如果有许多经常更改的着色器，着色器缓存文件夹可能会变得非常大。删除此文件夹是安全的；只会导致Unity 重新编译着色器变体

使用pragma 指令可以配置各种着色器编译器设置

在内置渲染管线中，可以让摄像机在运行时更改用于渲染特定几何体的着色器。可以这样做以实现视觉效果，例如边缘检测

在现代游戏开发的美术制作流程中，美术师将使用他们的3D 建模应用程序基于超高分辨率的源模型生成法线贴图。然后将法线贴图映射到可直接用于游戏的较低分辨率的模型版本，从而使用法线贴图渲染原始的高分辨率细节

Shader 对象包含一个或多个SubShader。通过SubShader 您可以为不同的硬件、渲染管线和运行时设置定义不同的GPU 设置和着色器程序。某些Shader 对象只包含一个SubShader；另一些包含多个SubShader 以支持一系列不同的配置

Unity 提供了许多后期处理效果和全屏效果，可以用很少的设置时间大大改善应用程序的外观。可以使用这些效果模拟物理摄像机和胶片属性，或创建风格化的视觉效果

可用的后期处理效果和这些效果的应用方式取决于所使用的渲染管线。一个渲染管线的后期处理解决方案与其他渲染管线不兼容

一个粒子系统可以模拟并渲染许多称为粒子的小图像或网格以产生视觉效果。系统中的每个粒子代表效果中的单个图形元素。系统共同模拟每个粒子以产生完整效果的印象。需要创建诸如火、烟或液体之类的动态对象时，由于很难用网格 (3D) 或精灵 (2D) 描绘这种对象，因此粒子系统非常有用。网格和精灵更适合于描绘诸如房屋或汽车之类的实体对象

内置粒子系统在 CPU 上模拟粒子行为。Visual Effect Graph 粒子系统解决方案可以在GPU 上运行以模拟数百万个粒子并创建大规模的视觉效果。Visual Effect Graph 还包含一个视觉图形编辑器，可帮助您创作可高度定制的视觉效果

为粒子添加噪声是创建有趣方案和效果的简单有效方法。例如，想象一下火焰中的余烬是如何移动的，或者烟雾在移动时是如何旋转的。强烈的高频噪声可用于模拟火焰余烬，而柔和的低频噪声更适合模拟烟雾效果

Visual Effect Graph 是一个可用于为Unity 项目创建大规模视觉效果的包。Visual Effect Graph 利用GPU 模拟粒子行为，可模拟的粒子数量远远超过内置粒子系统。如果要创建包含大量粒子的视觉效果并且需要高度可自定义的行为，请使用Visual Effect Graph 而不是内置粒子系统

天空是摄像机在渲染帧之前绘制的一种背景类型。此类型的背景对于3D 游戏和应用程序非常有用，因为它可以提供深度感，使环境看上去比实际大小大得多。天空本身可以包含任何对象（例如云、山脉、建筑物和其他无法触及的对象）以营造遥远三维环境的感觉。Unity 还可以将天空用于在场景中产生真实的环境光照

Unity Editor 允许您使用传统的伽马颜色空间以及线性颜色空间。伽马颜色空间是历史悠久的标准格式，但线性颜色空间渲染可提供更精确的结果

高动态范围 (HDR) 技术能够产生比标准动态范围 (SDR) 图像更高的亮度动态范围的图像，可以对颜色和亮度进行逼真的描绘

要在地形和粒子系统上创建风的效果，可使用Wind Zone 组件添加一个或多个游戏对象。风区内的树会以逼真的动画弯曲，而风本身以脉冲方式移动，从而在树之间营造自然的运动模式

Unity 可帮助您在项目中模拟物理系统，以确保对象正确加速并对碰撞、重力和各种其他力做出响应

默认情况下，Unity 几乎将所有游戏脚本都编译到预定义程序集Assembly-CSharp.dll 中

Unity 的音频功能包括全3D 空间音效、实时混音和母带制作、混音器层级视图、快照、预定义效果等等

如果游戏缺少某种音频，无论是背景音乐还是其他音效，那么游戏是不完整的。Unity 的音频系统既灵活而又强大。它可以导入大多数标准音频文件格式，精通于在3D 空间中播放声音，还可根据需要提供其他效果（比如回声和滤波）。Unity 还可以通过用户机器上任何可用麦克风来录制音频，以便在游戏过程中进行使用或存储和传输

Unity 混音器 (Audio Mixer) 允许您混合各种音频源，对音频源应用效果，以及执行母带制作 (mastering)

Unity 的动画功能包括可重定向动画、运行时对动画权重的完全控制、动画播放中的事件调用、复杂的状态机层级视图和过渡、面部动画的混合形状等等

Unity 使用Avatar 系统来识别布局中的特定动画模型是否为人形，以及模型的哪些部分对应于腿、手臂、头和躯干。由于不同人形角色之间骨骼结构的相似性，可将动画从一个人形角色映射到另一个角色，允许重定位和反向运动学 (IK)

状态机行为是一类特殊脚本。与将常规Unity 脚本 (MonoBehaviour) 附加到单个游戏对象类似，您可以将StateMachineBehaviour 脚本附加到状态机中的单个状态。因此可编写一些将在状态机进入、退出或保持在特定状态时执行的代码。这意味着您不必编写自己的逻辑来测试和检测状态的变化

Mecanim 的最强大功能之一是重定向人形动画。这意味着您可以相对轻松地将同一组动画应用于各种角色模型。重定向只适用于已配置了Avatar 的人形模型，因为这可以让我们在模型的骨骼结构之间建立对应关系

