---
layout: post
title: JVM Sandbox 原理分析
categories: 计算机科学 混沌工程 
tags: 混沌 混沌工程 分布式 ChaosBlade JavaAgent JVMSandbox ClassFileTransformer SandboxClassFileTransformer
---

混沌工程框架ChaosBlade 就是在JVM Sandbox 的基础上构建的

## JVM TI 原理

JVM TI（JVM TOOL INTERFACE，JVM 工具接口）是JVM 提供的一套对JVM 进行操作的工具接口。通过JVMTI 可以实现对JVM 的多种操作，它通过接口注册各种事件勾子，在JVM 事件触发的同时触发预定义的勾子，以实现对各个JVM 事件的响应

事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC 开始和结束、方法调用进入和退出、临界区竞争与等待、VM 启动与退出等等

当JVM 加载类文件时会触发类文件加载钩子事件ClassFileLoadHook，从而触发Instrumentation 类库中的ClassFileTransformer (字节码转换器)的transform 方法，在transfrom 方法中可以对字节码进行转换

## Java Agent 案例

Java Agent 是一种Java 技术，它可以在JVM（Java虚拟机）启动时或运行时加载，并附加到目标应用程序中。通过拦截、监控和修改类加载、方法调用、对象创建等操作，Java Agent 能够在不修改原始代码的情况下，对应用程序的行为进行修改或增强

Java Agent 主要通过Java 的Instrumentation API 来实现其功能。Instrumentation API 提供了一套用于修改Java类文件字节码的接口，使得Java Agent 可以在类加载到JVM之前或之后对其进行修改

编写Agent 程序，可以是premain 模式，也可以是agentmain 模式：

```java
public class MyAgent 
{
    // 使用 premain 可以在类第一次加载之前修改
    public static void premain(String agentArgs, Instrumentation inst) 
    {
        System.out.println("agentArgs : " + agentArgs);
        //加入自定义转换器
        inst.addTransformer(new MyTransformer(), true);
    }

    // agentmain 方式依赖于 Attach API，它允许在程序运行时，将一个新的 Agent 附加到正在运行的 JVM 上
    // 与 premain 模式不同的是，agentmain 模式并不需要在程序启动时就指定，而是可以在程序运行中后期动态地附加进去
    public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException 
    {
        System.out.println("Agent Main called");
        System.out.println("agentArgs : " + agentArgs);
        inst.addTransformer(new MyTransformer(), true);
        inst.retransformClasses(Account.class); 
    }
}
```

如上段代码所示，需要调用addTransformer() 方法，添加转换器，这个转换器就是对字节码处理的关键所在：

```java
public class MyTransformer implements ClassFileTransformer 
{
    @Override
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
                            ProtectionDomain protectionDomain, byte[] classfileBuffer) {
        // 检查是否是我们想要修改的类
        if (!className.equals("com/leon/BusinessService")) {
            return null; //不是我们关心的类，直接返回原始字节码
        }

        try {
            //借助JavaAssist工具，进行字节码插桩
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.get("com.leon.BusinessService");
            CtMethod personFly = cc.getDeclaredMethod("doBusiness");

            //在目标方法前后，插入代码
            personFly.insertBefore("System.out.println(\"--- before doBusiness ---\");");
            personFly.insertAfter("System.out.println(\"--- after doBusiness ---\");");

            return cc.toBytecode();

        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }
}
```

>其实在Sandbox 中，核心类SandboxClassFileTransformer 就是ClassFileTransformer 的一个实现类

